funcs:
  - name: isValid
    type: asserter
    body: |
      function(text, name) {
        text = text.substring(2).trim()
        var words = text.split(" ")
        if (words[0].toLowerCase() === "deprecated") {
          return false
        }
        return words[0].toLowerCase() !== name.toLowerCase()
      }
  - name: fixComment
    type: resolver
    body: |
      function (text, name) {
        function testre(pat, text) {
          var re = new RegExp(pat)
          return re.test(text)
        }
        
        function lc(s) {
          return s.toLowerCase();
        }
        
        function uncapitalize(s) {
          return lc(s.charAt(0)) + s.slice(1);
        }
        
        function removeInitialWhitespace(s) {
          return s.replace(new RegExp("^ *", "i"), "")
        }
        
        // 'TODO' statements, et.
        function prependLineToLabel(s, commentChar) {
          if (testre("^[a-zA-Z]+:", s)) {
            if (commentChar === "//") {
              return "\n" + commentChar + " " + s
            }
            return "\n" + s
          }
          return s
        }
        
        function prependChecksACase(s, funcName, verbs) {
          startsWithVerb = false
        
          verbs.forEach(function(verb) {
            if (testre("^" + verb, lc(s))) {
              startsWithVerb = true
            }
          })
        
          if (! (startsWithVerb || testre("(case|test)", lc(s))) && testre("^test", lc(funcName))) {
            return "checks a case when " + s
          }
          return s
        }
        
        function colonify(s) {
          if (testre("^[A-Z][a-z]* ", s)) {
            return "; " + s
          }
        
          if (testre("^[a-zA-Z]*s ", s)) {
            return " " + s
          }
        
          if (testre("^(will|does)", s)) {
            return " " + s
          }
        
          return "; " + s
        }
        
        function updateOld(s, name) {
          var result = s
          var words = s.split(" ")
        
          //Split first word into camel-cased subwords
          words[0].split(/([A-Z][a-z]*)/).forEach(function(word) {
            if (word.length < 4) return
            // If start of comment smells like an old name
            if (lc(word).indexOf(lc(name)) !== -1 ||
                lc(name).indexOf(lc(word)) !== -1) {
              words[0] = name
            }
          })
          return words.join(" ")
        }
        
        var verbs = ["test", "ensure", "replace", "get", "start",
                     "validate", "demonstrate", "compare", "hook",
                     "declare", "check", "retrieve", "render"];
        var nouns = ["test", "function", "method"];
        var adjectives = ["various"];

        function fixLeadingVerb(s) {
            // Make these replacements before removing from the front
            verbs.forEach(function(verb) {
                var pverb = verb + "s"
                s = s.replace(new RegExp("^" + verb + "s\? +", "i"), pverb + " ")

                adjectives.forEach(function(adjective) {
                    s = s.replace(new RegExp("^" + pverb + " " + adjective + " ", "i"), pverb + " " + lc(adjective) + " ")
                })
            })
            return s
        }
        
        function rewordComment(s, name, commentChar) {
          s = s.replace(new RegExp("^(The|This) " + name + " ", "i"), "")
        
          // Make these replacements before removing from the front
          s = fixLeadingVerb(s)
        
          nouns.forEach(function(noun) {
            s = s.replace(new RegExp("^(This) " + noun + " ", "i"), "")
          })
        
          s = updateOld(s, name)
          s = s.replace(new RegExp("^" + name + "[a-z]* ?", "i"), "")    // Remove name from start including extra alphas and space if exists
          s = fixLeadingVerb(s)
          s = s.replace(new RegExp("^[a-z]+([A-Z]+[a-z]+)+ "), "") // Remove leading camelCase
          s = s.replace(new RegExp("^([A-Z]+[a-z]+){2,} "), "")    // Remove leading PascalCase. Must come after remove name
          s = s.replace(new RegExp("^This( example)? ", "i"), "")
          s = prependChecksACase(s, name, verbs)
          s = s.replace(new RegExp("^Purpose ", "i"), "The purpose ")
          if (testre("^[A-Z][a-z]+s ", s)) {
            s = uncapitalize(s)
          }
        
          return name + colonify(s)
        }

        var commentChar = text.substring(0, 2)
        var commentString = text.substring(2).trim()
      
        commentString = commentString.replace(new RegExp("^[/*]* ", "i"), " ") // Remove extra leading comment chars
      
        // Do nothing if comment does not start with alphanumerics
        if (! testre("^ ?[A-Za-z]", commentString)) {
          return text
        }
      
        commentString = removeInitialWhitespace(commentString)
        commentString = prependLineToLabel(commentString, commentChar)
        return commentChar + " " + rewordComment(commentString, name, commentChar)
      }
tenets:
  - name: comment-first-word-as-subject
    flows:
      codelingo/docs:
        title: Comment First Word as Subject
        body: |
          Doc comments work best as complete sentences, which allow a wide variety of automated presentations.
          The first sentence should be a summary that starts with the name being declared.
      codelingo/review:
        comment: |
          Every exported function in a program should have a doc comment. The first sentence should be a summary that starts with the name ({{funcName}}) being declared.
          From [effective go](https://golang.org/doc/effective_go.html#commentary).
      codelingo/rewrite:
        place: holder
    query: |
      import codelingo/ast/go

      # Only look at exported functions
      go.func_decl(depth = any):
        go.comment_group:
          @review comment
          @rewrite --replace "{{fixComment(commText, funcName)}}"
          go.comment:
            sibling_order == 0
            text as commText
        go.ident:
          name as funcName
          isValid(commText, funcName)